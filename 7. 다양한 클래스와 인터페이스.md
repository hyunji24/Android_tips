##  1. 추상 클래스와 인터페이스



### 📌 추상 클래스  



- 추상 클래스 : 선언 등의 대략적인 설계 명세와 공통의 기능을 구현한 클래스
- 추상 클래스를 상속하는 하위 클래스는 추상 클래스의 내용을 구체화해야 한다.
- abstract 키워드와 함께 선언
- 프로퍼티나 메서드도 abstract로 선언 가능 -> 미완성되었다는 의미 부여 가능
- 클래스에서 추상 프로퍼티/메서드가 하나라도 있다면 해당 클래스는 추상 클래스가 되어야함

|                          | 추상클래스 | 인터페이스 |
| ------------------------ | :--------: | :--------: |
| 프로퍼티에 상세정보 저장 |     ㅇ     |     x      |
| 객체 생성                |     x      |     x      |
| 다중 상속                |     x      |     ㅇ     |

```kotlin
abstract class AbstractVehicle(val name:String,val color:String,val weight:Double){

    //추상 프로퍼티 (반드시 하위클래스 재정의)
    abstract var maxSpeed:Double 

    //일반 프로퍼티(초깃값인 상태 저장 가능)
    var year="2021"

    //추상 메서드 (반드시 하위클래스 재정의)
    abstract fun start()
    abstract fun stop() 

    //일반 메서드
    fun displaySpecs(){
        println("Name: $name, Color: $color, MaxSpeed: $maxSpeed")

    }
}

class Car(name:String, color:String, weight: Double, override var maxSpeed:Double):AbstractVehicle(name,color,weight) 
//maxSpeed 오버라이딩

{
    override fun start() {
        println("start")
}

    override fun stop() {
        println("stop")

    }

}

fun main(){
    val car=Car("BMW","red",1110.0,270.0)
    car.year="2020"

    car.displaySpecs()
    car.start()
}

```

- 추상클래스에서는 상속을 위해 open키워드 사용할 필요 x -> abstract 키워드 자체가 상속과 오버라이딩을 이용하고 있음  
- 추상 클래스의 일반 프로퍼티/메서드 : 연관성이 높은 클래스의 기능/속성 미리 정의  
    
  



**✔object 키워드를 사용해서 단일 인스턴스로 객체 생성하기**

 ```kotlin
 abstract class Printer{
 	abstract fun print() //추상 메서드
 }
 
 val myPrinter = object: Printer(){ //객체 인스턴스
 	override fun print() //추상 메서드의 구현
 }
 ```

- 추상 클래스로부터 하위 클래스를 생성하지 않고 객체 생성 가능  
    
  



### 📌 인터페이스  



- 추상 클래스처럼 프로퍼티를 통해 상태를 저장할 수 없다. 
- 인터페이스 또한 객체를 생성할 수 없고 하위 클래스 통해 구현 및 생성

​	❔ *왜 인터페이스를 사용?* 

```
- 추상 클래스도 상속을 통해 하위 클래스로 확장 가능, 그러나 2개 이상의 클래스로부터 프로퍼티나 메서드 상속 받을 수 없음
- 하위 클래스는 상위 클래스의 영향을 받음
+ 인터페이스는 '구현 클래스'너낌... 
+ 구현 클래스의 목적은 인터페이스가 제시한 메서드를 구체적으로 '구현'
+ 원하는 만큼 구현 클래스에 붙여서 메서드 구현하면 됨
+ 인터페이스가 바뀐다고 해도 그것을 구현하는 클래스에는 크게 영향 끼치지 않음
```

![](C:\Users\Hyeonji\Desktop\interface.JPG)





```kotlin
interface Pet{
    var category: String //기본은 추상 프로퍼티
    fun feeding() //추상 메서드
    fun patting(){ //일반 메서드(구현부 있음)
        println("keep patting!")
    }
    
    val msgTags:String
    	get()="I'm your cat"
}

class Cat(override var category: String) :Pet{
    override fun feeding() {
        println("feed")
    }

}

fun main(){
    val obj=Cat("small")
    println("${obj.category}")
    obj.feeding() //구현된 메서드
    obj.patting() //기본 메서드
    
    println("${obj.msgTags}")
}
```

- 추상 프로퍼티/추상 메서드는 override 키워드 사용해서 구현
- 인터페이스는 프로퍼티에 값을 저장할 수 없지만 val로 선언된 프로퍼티는 게터를 통해 내용 구현 가능! (field 사용 x -> 받은 value 를 저장할 수는 없음)



**✔인터페이스 구현의 필요성**

```kotlin
open class Animal(val name:String) //상속 위해 open class로 생성

class Dog(name:String,override var category:String): Animal(name),Pet{
    override fun feeding() {
        println("feed a dog")
    }
}

class Cat(name:String,override var category:String): Animal(name),Pet{
    override fun feeding() {
        println("feed a cat")
    }

}

class Master{ //애완동물 종류에 따라 playWithPet 오버로딩됨
    fun playWithPet(dog:Dog){
        println("Enjoy with my dog")
    }
    fun playWithPet(cat:Cat){
        println("Enjoy with my cat")
    }
}

fun main(){
    val master=Master()
    val dog=Dog("Tom","small")
    val cat=Cat("Coco","fat")
    master.playWithPet(cat)
    master.playWithPet(dog)
}
```

- 애완동물의 종류가 많아지면 비효율적!

```kotlin
interface Pet{
    var category: String 
    var species:String //종을 위한 프로퍼티
    fun feeding() 
    
    val msgTags:String
    	get()="I'm your cat"
}

class Cat(name:String,override var category:String): Animal(name),Pet{
	override var species:String="cat"
    override fun feeding() {
        println("feed a cat")
    }

}

class Master{ /
    fun playWithPet(pet:Pet){
        println("Enjoy with my ${pet.species}")
    }
    
}
```

- Master : Cat/Dog 에 의존적 -> 인터페이스를 이용해 의존성 제거!! 



**✔여러 인터페이스를 이용한 다중 상속**

```kotlin
interface Bird {
    val wings: Int //기본은 추상 프로퍼티
    fun fly()
    fun jump() {
        println("bird jump!")
    }
}

interface Horse {
    val maxSpeed: Int
    fun run()
    fun jump() {
        println("jump!, max speed: $maxSpeed")
    }
}

class Pegasus: Bird, Horse {
    override val wings: Int = 2
    override val maxSpeed: Int = 100
    override fun fly() {
        println("Fly!")
    }
    override fun run() {
        println("Run!")
    }
    override fun jump() {
        //super<Horse>.jump()
        println("Pegasus Jump!")
    }
}

fun main() {
    val pegasus = Pegasus()
    pegasus.fly()
    pegasus.run()
    pegasus.jump()
}
```

- 두 개의 인터페이스(Bird,Horse) 상속
- 모든 추상 프로퍼티, 메서드 오버라이딩해서 구현해줘야 함. (wings,maxSpeed,fly(),run())
- 기본 구현이 되어있는 jump()는 필요에 따라서만 오버라이딩
  - 👀 근데 오버라이딩을 해주긴 해야함.  두 개의 인터페이스(Bird,Horse)   모두 jump()라는 메서드를 가지고 있기 때문에
  - 만약 인터페이스 두개 중 하나에서 jump()메서드를 없애면 Pegasus에서 오버라이딩 하지 않아도 쓸 수 있음  
    

  


**✔인터페이스의 위임**  

- 인터페이스에서도  by 위임자를 사용할 수 있다.

  - 인터페이스 A와 B를 매개변수로 사용한 클래스C

    ```kotlin
    interface A{
        fun functionA(){}
    }
    
    interface B{
        fun functionB(){}
    }
    
    class C(val a:A, val b:B){
        fun functionC(){
            a.functionA()
            b.functionB()
        }
    }
    ```

    

  - by 위임자를 사용한 클래스C

    ```kotlin
    class C(a:A,b:B): A by a, B by b{
        fun functionC(){
            functionA()
            functionB()
        }
    ```

    - 점(.) 표기법 없이 메서드 접근 가능

- 위임을 이용한 멤버 접근
- Person 클래스가 상속과 같은 형태로 위임을 사용하고 있음

  ```kotlin
  interface Nameable{
      var name:String
  }
  
  class StaffName:Nameable{
      override var name: String="Sean"
  }
  
  class Work:Runnable{ //스레드 실행 위한 인터페이스
      override fun run() {
          println("work..")
      }
  }
  
  //1. 각 매개변수에 해당 인터페이스 위임
  class Person(name:Nameable,work:Runnable): Nameable by name, Runnable by work
  
  fun main(){
      val person=Person(StaffName(),Work()) //2. 생성자를 사용해 객체 바로 전달
      println(person.name) //3. 여기서 StaffName클래스의 name접근
      person.run() //4. 여기서 Work클래스의 run 접근
  }
  ```

    
  

👀 **커피제조기 실습!**   
  




정리하자면..인터페이스를 사용하는 이유는..

```
① 특정 구현에 의존적이지 않은 코드를 만들 수 있음
② 정의와 구현 분리할 수 있음
③ 내용을 확장/ 교체 하기 쉬움
```

  
  




## 2. 데이터 클래스와 기타 클래스

  


### 📌 데이터 클래스

- 구현 로직 없이 오로지 데이터를 기술하는 용도로 사용되는 클래스
- 게터/세터, equals(), toString(), copy(), hashCode(), component1() 자동 생성됨
- 데이터를 주고받는 표준 방법

 ``` 
 data class Customer(var name:String, var email:String)
 ```

- 데이터 클래스의 조건
  - 주 생성자는 최소한 하나의 매개변수를 가져야 한다.
  - 주 생성자의 모든 매개변수는 val, var로 지정된 프로퍼티여야 한다.
  - 데이터 클래스는 abstract, open, sealed, inner 키워드를 사용할 수 없다.
- 필요하다면 부 생성자나 init블록을 넣어 데이터를 위한 간단한 로직은 포함 가능

```kotlin
data class Customer(var name:String, var email:String){
    var job:String="Unknown"
    constructor(name:String,email:String, _job:String):this(name,email){
        job=_job
    }
    init{
        //간단한 로직
    }
}
```

  


**✔데이터 클래스가 자동 생성하는 메서드**

| 제공된 메서드 |                             기능                             |
| :-----------: | :----------------------------------------------------------: |
|   equals()    | 두 객체의 내용이 같은지 비교(고유 값은 다르지만 의미 값 같을 때) |
|  hashCode()   |           객체를 구별하기 위한 고유한 정숫값 생성            |
|    copy()     |       빌더 없이 특정 프로퍼티만 변경해서 객체 복사하기       |
|  toString()   |            데이터 객체를 읽기 편한 문자열로 반환             |
| componentN()  | 객체의 선언부 구조를 분해하기 위해 프로퍼티에 상용하는 메서드 |

  


**✔객체 디스트럭처링(Destructuring)**

- 객체가 가지고 있는 프로퍼티를 개변 변수로 분해하여 할당하는 것

  ```kotlin
  val cus1=Customer("Sean","sean@gmail.com")
  
  val(name, email)=cus1
  println("name=$name, email=$email")
  ```

  ```kotlin
  val (_, email)=cus1 //첫번째 프로퍼티 제외
  
  val name2=cus1.component1()
  val email2=cus2.component2()
  
  ```

- 데이터가 많아진다면..

  - in 연산자 이용

  ```kotlin
  val cus2=Customer("Bob","bob@gmail.com")
  val cus3=Customer("Bob","bob@gmail.com")
  
  val customers=listOf(cus1,cus2,cus3)
  
  for((name,email) in customers){
  	println("name=$name, email=$email")
  }
  ```

  - 함수로 객체 반환

  ```kotlin
  fun myFunc():Customer{
  	return Customer("Mickey","mic@gmail.com")
  }
  val (myName,myEmail)=myFunc()
  ```

  - 람다식 사용

  ```kotlin
  val myLamda={
  	(nameLa,emailLa):Customer ->
  		println(nameLa)
  		println(emailLa)
  }
  myLamda(cus1)
  ```

    
    
  

### 📌 내부 클래스 기법  

- 기법 2가지

  - 중첩 클래스 (클래스 안에 또 다른 클래스)

  - 내부 클래스 ( 독립적인 클래스로 정의하기 모호 / 내부에서만 사용하고 외부 접근 필요x)

    -> 남용하면 클래스 의존성 커지고 코드 어려워짐. 주의!

|              자바               |                            코틀린                            |
| :-----------------------------: | :----------------------------------------------------------: |
| 정적 클래스<br />(Static Class) |     중첩 클래스(Nested Class): 객체 생성 없이 사용 가능      |
| 멤버 클래스<br />(Member Class) | 이너 클래스(Inner Class) : 필드나 메서드와 연동하는 내부 클래스로 inner 키워드 필요 |
| 지역 클래스<br />(Local Class)  | 지역 클래스(Local Class): 클래스의 선언이 블록 안에 있는 지역 클래스 |
|  익명 클래스(Anonymous Class)   | 익명 객체(Anonymous Object): 이름이 없고 주로 일회용 객체를 사용하기 위해 object키워드 통해 선언 |

```kotlin
//자바의 멤버(이너) 클래스
class A{
	class B{ 
	...//외부 클래스 A의 필드에 접근 가능
	}
}

//코틀린의 이너 클래스
class A{
	inner class B{ //inner 키워드 필요
    ... //외부 클래스 A의 필드에 접근 가능
	}
}
```

```kotlin
//자바의 정적 클래스
class A{
	static class B{ //정적 클래스를 위해 static키워드 사용
	...
	}
}

//정적 클래스처럼 사용한 코틀린의 중첩 클래스
class A{
	class B{ //코틀린에서 아무 키워드 없는 클래스는 중첩 클래스이며 정적 클래스처럼 사용
		... //외부 클래스 A의 프로퍼티, 메서드에 접근할 수 없음
	}
}
```



### 1️⃣ 중첩 클래스

- 객체 생성 없이 접근할 수 있음

```kotlin
class Outer {
    val ov = 5
    class Nested {
        val nv = 10
        fun greeting() = "[Nested] Hello ! $nv" // 외부의 ov에는 접근 불가
    }
    fun outside() {
        val msg = Nested().greeting() // 객체 생성 없이 중첩 클래스의 메서드 접근
        println("[Outer]: $msg, ${Nested().nv}") // 중첩 클래스의 프로퍼티 접근
    }
    

fun main() {
    // static 처럼 Outer의 객체 생성 없이 Nested객체를 생성 사용할 수 있음
    val output = Outer.Nested().greeting()
    println(output)
    Outer.Nested().accessOuter()

    //Outer.outside()  // 에러! 외부클래스 경우는 객체 생성 필요
    val outer = Outer()
    outer.outside()
}
```

- 중첩된 Nested 클래스는 바로 바깥 클래스인 Outer 멤버에는 접근 불가

  - 접근 방법이 있나? -> Outer 클래스가 컴패니언 객체 가지고 있을 때는 접근 가능

  ```kotlin
  class Outer {
      val ov = 5
      class Nested {
         ...
          fun accessOuter() { // 컴페니언 객체는 접근할 수 있다.
              println(country)
              getSomething()
          }
      }
      companion object { // 컴페니언 객체는 static 처럼 접근 가능
          const val country = "Korea"
          fun getSomething() = println("Get something...")
      }
  }
  
  
  ```

  - 외부 클래스 멤버에 접근하기 위한 또 다른 방법.. 이너 클래스

  


### 2️⃣ 이너 클래스

- inner 키워드를 사용해서 선언
- 외부 클래스의 멤버들 접근 가능, private 멤버도 접근 가능

```kotlin
class Smartphone(val model: String) {

    private val cpu = "Exynos"

    inner class ExternalStorage(val size: Int) {
        fun getInfo() = "${model}: Installed on $cpu with ${size}Gb" 
        // 바깥 클래스의 프로퍼티 접근
    }
}

fun main() {
    val mySdcard = Smartphone("S7").ExternalStorage(32)
    println(mySdcard.getInfo())

}
```

- 외부 클래스인 Smartphone의 프로퍼티 model과 cpu(private)에 접근 가능

  


### 3️⃣ 지역 클래스

- 특정 메서드의 블록이나 init블록과 같이 블록 범위에서만 유효한 클래스
- 블록 범위를 벗어나면 더 이상 사용되지 않음

```kotlin
class Smartphone(val model: String) {

    private val cpu = "Exynos"
    
    fun powerOn(): String {
        class Led(val color: String) {  // 지역 클래스 선언
            fun blink(): String = "Blinking $color on $model" 
            // 외부의 프로퍼티는 접근 가능
        }
        val powerStatus = Led("Red")
        return powerStatus.blink()
    } //powerOn() 블록 끝
}

fun main() {
    val myphone = Smartphone("Note9")
    myphone.ExternalStorage(128)
    println(myphone.powerOn())
}
```

- Led클래스는 Smartphone 클래스의 메서드인 powerOn()에서만 유효
- Led클래스에서 외부 멤버인 프로퍼티는 접근 가능

  


### 4️⃣ 익명 객체

- object 키워드를 사용하는 익명 객체를 통해 일회성으로 객체 생성하고 사용
- 익명 객체 기법으로 다중의 인터페이스 구현 가능

```kotlin
interface Switcher{
	fun on():String
}

class Smartphone(val model:String){ //1. 인터페이스 선언
	..
	fun powerOn():String{
		val powerSwitch= object:Switcher{ //2. 익명객체 사용해 Switcher의 on()
			override fun on():String{
				return powerStatus.blink()
			}
		} //익명(object) 객체 블록의 끝
		return powerSwitch.on()  //익명 객체의 메서드 사용
	}
}
```

- object 를 사용 -> Switcher 인터페이스로부터 만들어진 객체는 이름이 없으며 powerSwitch 프로퍼티를 위해 일회성으로 사용됨
- 이 메서드가 호출될 때마다 일회성 객체의 인스턴스가 만들어짐

  
  


### 📌 실드 클래스와 열거형 클래스  

  


### 1️⃣ 실드 클래스

- 미리 만들어 놓은 자료형들을 묶어서 제공

- sealed 키워드를 class와 함께 사용

- 실드 클래스 자체로는 객체 만들 수 없음

- 생성자도 기본적으로는 private , 다른 건 허용x

- 같은 파일 안에서는 상속 가능, 다른 파일에서는 상속 불가능하게 제한

- 블록 안에 선언되는 클래스는 상속이 필요한 경우 open키워드로 선언될 수 있음

  - 선언 방법 1

  ```kotlin
  sealed class Result{
      open class Success(val message:String):Result() //상속 가능
      class Error(val code:Int, val message:String):Result()
  }
  
  class Status:Result() //실드 클래스 상속: 같은 파일 내에서만
  class Inside: Result.Success("Status")
  ```

  - 선언 방법2

  ```kotlin
  sealed class Result
  
  open class Success(val message:String):Result() //상속 가능
  class Error(val code:Int, val message:String):Result()
  
  class Status:Result() 
  class Inside: Success("Status") //.점 없이 사용
  
  ```

  ```kotlin
  fun main() {
      // Success에 대한 객체 생성
      val result = Result.Success("Good!")
      val msg = eval(result)
      println(msg)
  }
  
  // 상태를 검사하기 위한 함수
  fun eval(result: Result): String = when(result) {
      is Status -> "in progress"
      is Result.Success -> result.message
      is Result.Error -> result.message
      // 모든 조건을 가지므로 else 가 필요 없다
  }
  ```

- sealed Class 왜 사용하지? 특정 객체 자료형에 따라 when문과 is에 의해 선택적으로 실행 가능

- 이너 클래스/중첩 클래스로 구현하려고 하면 모든 경우의 수 컴파일러가 직접 판단x

- sealed Class 사용하면 필요한 경우의 수 직접 지정 가능

```
<details>
<summary>여기를 눌러주세요</summary>
<div markdown="1">       

Sealed class는 Super class를 상속받는 Child 클래스의 종류 제한하는 특성을 갖고 있는 클래스입니다. 어떤 클래스를 상속받는 하위 클래스는 여러 파일에 존재할 수 있기 때문에 컴파일러는 얼마나 많은 하위 클래스들이 있는지 알지 못합니다. 하지만 Sealed class는 동일 파일에 정의된 하위 클래스 외에 다른 하위 클래스는 존재하지 않는다는 것을 컴파일러에게 알려주는 것과 같습니다.

예를 들어 Color라는 상위 클래스를 만들고, 동일한 파일에 이 클래스를 상속하는 Red, Blue 라는 클래스를 선언했다고 가정해보세요. Sealed class는 이 두개의 클래스 외에 Color 클래스를 상속받는 다른 클래스는 없다라는 것을 컴파일러에게 말해줍니다.

이렇게 하위 클래스가 될 수 있는 클래스를 제한하여 얻을 수 있는 장점 중 하나는 when을 사용할 때 else를 사용하지 않는 것입니다

</div>
</details>
```

  


### 2️⃣ 열거형 클래스

- 여러 개의 상수를 선언하고 열거된 값을 조건에 따라 선택할 수 있는 특수한 클래스
- 다양한 자료형을 다루지는 못함
- enum  키워드와 함께 선언
- 자료형이 동일한 상수 나열할 수 있음

```kotlin
enum class Direction{
	NORTH, SOUTH, EAST, WEST
}
```

```kotlin
enum class DayOfWeek(val num:Int){
	MONDAY(1),TUESDAY(2),...SUNDAY(7)
}

val day=DayOfWeek.SATURDAY
when(day.num){
	1,2,3,4,5-> println("WeekDay")
	6,7 -> println("Weekend!")
}
```



- 메서드도 포함 가능, 이때는 세미콜론(;)을 이용해 열거한 상수 객체 구분 후 메서드 선언.
- when문을 사용해 각 케이스 처리 가능
- 기본적인 멤버: 상수 이름 자체를 반환하는 name, 이름 가져오는 toString(), 일종의 순서번호 ordinal(0부터 시작)
- 열거형 클래스에서 인터페이스의 메서드도 구현 가능

```kotlin
interface Score {
    fun getScore(): Int
}

enum class MemberType(var prio: String) : Score {
    NORMAL("Third") {
        override fun getScore(): Int  = 100
    },
    SILVER("Second") {
        override fun getScore(): Int  = 500
    },
    GOLD("First") {
        override fun getScore(): Int  = 1500
    }
}

fun main() {
    println(MemberType.NORMAL.getScore())
    println(MemberType.GOLD)
    println(MemberType.valueOf("SILVER"))
    println(MemberType.SILVER.prio)

    for (grade in MemberType.values()) { //모든 값 가져오는 반복문
        println("grade.name = ${grade.name}, prio = ${grade.prio}")

    }
}
```

  


### 3️⃣ 애노테이션 클래스

- 애노테이션: 코드에 부가 정보를 추가하는 역할

- @ 기호와 함께 나타냄, 주로 컴파일러나 프로그램 실행 시간에서 사전 처리 위해 사용

- 표준 애노테이션 (자바와 원활하게 연동하는 데 목적을 둠)

  - @JvmName 

  ```kotlin
  @JvmName("filterStrings")
  fun filter(list:List<String>) : Unit
  
  @JvmName("filterInts")
  fun filter(list:List<Int>) : Unit
  
  //filter()라는 이름을 자바에서 각각 filterStrings()와 filterInts()로 바꿔주는 것
  ```

  - @JvmStatic : 자바의 정적 메서드로 생성할 수 있게 해줌,자바코드에서 컴패니언 객체 접근 가능하게 함
  - @Throw: 코틀린의 throw 구문이 자바에서도 포함되도록 함

  ```
  class File(val path:String){
  	@Throws(FileNotFoundException::class)
  	fun exists(): Boolean{
  		if(!Paths.get(path).toFile().exists())
  		throw FileNotFoundException("$path does not exist")
  		return true
  	}
  }
  ```

    
    
  

### 📌 연산자 오버로딩

- 다형성의 한 경우
- 같은 연산자에 여러 가지 다른 의미의 작동 부여 가능

​      


**✔연산자의 작동방식**  


- 연산자를 사용하면 관련 멤버 메서드를 호출하는 것과 같다.
- a+b -> a.plus(b) 가 내부적으로 호출되는 것
- 기본형을 위한 오버로딩된 plus()함수

![plus](C:\Users\Hyeonji\Desktop\plus.JPG)



- 예시

```kotlin
class Point(var x:Int=0,var y:Int=10){
    operator fun plus(p:Point):Point{ //+연산자 오버로딩
        return Point(x+p.x, y+p.y)
    }
    
    operator fun dec() = Point(--x,--y) //--연산자 오버로딩
}

fun main() {
    val p1=Point(3,-8)
    val p2=Point(2,9)

    var point=Point()
    point = p1 + p2
    println("point=(${point.x},${point.y})") //(5,1) 출력됨
    
    --point
    println("point=(${point.x},${point.y})") //(4,0) 출력됨
}
```

​    

**✔연산자의 종류**

1. 산술 연산자 (+,-,*,/,%,..)

2. 호출 연산자 : 함수 호출 돕는데 사용

   ```kotlin
   class Manager{
       operator fun invok(value:String){
           println(value)
       }
   }
   
   fun main(){
       val manager=Manager()
       manager("Do something!") //manager.invoke("..")형태로 호출됨 , invoke생략
   }
   ```

   ```kotlin
   val sum= {x: Int, y: Int -> x+y} //람다식에는 기본적으로 invoke가 정의 됨
   sum.invoke(3,10) //2개의 인자 받는 객체 a.invoke(i,j)는 a(i,j)형태로 사용 가능
   sum(3,10)
   ```

3. 인덱스 접근 연산자 (a[i], a[i,j]...) -> a.get(i)

4. 단일 연산자 : 먼저 a의 자료형을 결정. 각 연산자에 대한 함수 호출 후 연산 결과 반환

   ```kotlin
   data class Point(val x: Int, val y: Int)
   
   operator fun Point.unaryminus()=Point(-x,-y) //-a
   
   val point=Point(10,20)
   println(-point) // 단일 연산자에 의해(-10,20)
   ```

5. 범위 연산자 (in) -> contains()메서드 이용해서 오버로딩

6. 대입 연산자

   ```
   +에 대응하는 plus()를 오버로딩하면 +=는 자동으로 구현됨.
   plusAssign()을 따로 오버로딩할 필요 없음. 동시에 오버로딩 시 모호해져 오류 발생
   ```

7. 동등성 연산자

   ```
   - ==, != 둘다 equals()로 변경되어 동작
   - 📌주의: a와 b과 둘 다 null이면 true 반환
   - equals 는 Anu 안에 operator 키워드가 붙어서 구현되어 있기 때문에 하위클래스에서는    override 키워드 사용해서 ==과 치환 가능
   - equals는 확장 함수로 구현할 수 없음
   ```

8. 비교 연산자 (<.>,=,<=)

